# 预处理器

尽管CSS已经很棒了，但是还是缺少很多设计师和开发者所需要的特性。不过，现在已经有人开发了工具来填补这方面的空白，提高我们的开发效率。

这种类型的工具是CSS预处理器。我将会重新介绍什么是预处理器以及它能做什么，并使用它构建可扩展的，模块化的CSS。

## 什么是预处理器？

CSS预处理器可以在CSS中使用特殊的语法，然后编译成浏览器中运行的CSS。有些预处理器的语法尽可能地贴近CSS原生语法，而有些预处理器则偏向尽可能简化的语法。

我们来看个[Stylus](http://learnboost.github.com/stylus/)预处理的例子：

```stylus
// 使用Stylus编码
@import 'vendor'

body
  font 12px Helvetica, Arial, sans-serif

a.button
  border-radius 5px
```

对于使用过[Ruby](http://www.ruby-lang.org/en/) 或是[CoffeeScript](http://coffeescript.org/)的同学，可能会感到很熟悉，它去掉了花括号和分号，而使用空格来替代。缩进代表哪些属性适用于那些规则，属性名称中不能有空格，所以第一个空格分隔了属性和属性值。

除了Stylus之外，还有两个预处理器也深受欢迎，[Sass](http://sass-lang.com/)（[Compass](http://compass-style.org/)）, 以及[Less](http://lesscss.org/)。

## 安装预处理器

对于安装预处理器，有些人（尤其是设计师，他们不那么熟悉命令行）会抱怨安装过于复杂。其实这取决于你的环境，如果环境允许，安装预处理器可以像把应用拖进你的应用文件夹中这么简单。

比如在Mac上安装Sass，我只要在终端上键入命令行即可

```
# 安装Sass
sudo gem install sass
```

```
# 安装Compass
sudo gem install compass
```

[gem](http://rubygems.org/)是Ruby的包管理工具，它已经在最新版本的Mac OS X中预装。

装好Sass之后，我可以设置Sass监控我的工作区

```
# 运行Sass
sass --watch before:after
```
`before`文件夹放置了所有的`.scss`（需要预编译的CSS文件）文件，`after`则是编译后的CSS文件存储的文件夹。任何在`before`文件夹里对`.scss`文件的修改都会自动编译成新的CSS文件，然后存储在`after`文件夹里。在开发过程中，这对于快速构建和测试十分方便。（`.scss`文件和普通`.css`文件一样，只不过使用Sass语法，我会在之后的章节里做介绍）

如果你不喜欢命令行，这里也有一个[Compass Mac App](http://compass.handlino.com/)。

Less需要使用npm（[node包管理工具](https://github.com/isaacs/npm)）安装，所以你需要先安装node包管理工具，然后安装Less。Less有Javascript版本，所以你可以在浏览器中运行它。

```html
<!-- Less运行在浏览器中 -->
<link rel="stylesheet/less" type="text/css" href="styles.less">
<script src="less.js"></script>
```
千万不要在实际站点中部署Less，将Less语法转换为CSS再部署。

```
# 更简单的Less命令行
lessc styles.less
```
网站开发越来越需要命令行工具了，它们可以精简你的开发流程，甚至能够让你脱离GUI工具，解决一些GUI工具并不能解决的事情。

## 预处理器有用的特性

预处理器提供了很多有趣的功能使得我们编写CSS更加简单。以下列出了其中一部分：

+ 变量（Variables）
+ 操作符（Operations）
+ 混入（Mixins）
+ 嵌套（Nesting）
+ 函数（Functions）
+ 插值（Interpolation）
+ 文件导入（File importing）
+ 扩展（Extending）

这些都什么意思呢？让我们对其中一部分做一个深入的了解。（我将会使用Sass来进行演示，需要注意的是，Less和Stylus对于相同的概念也有类似的方法）

### 变量

任何写过CSS的人可能不只一次地希望可以在一个CSS文件中设置一个颜色值，然后在其他CSS文件中重用这个颜色。在Sass中，你可以用`$`定义一个变量，并对它进行赋值。

```scss
// 使用变量
$color: #369; 

body {
    color: $color;
}

.callout {
    border-color: $color;
}
```

编译器会将上述代码转换为以下代码
```css
/* 编译后的变量 */
body {
    color: #369;
}

.callout {
    border-color: #369;
}
```
这对于在一个地方保存整个网站的变化十分有帮助。（值得注意的是，W3C正在制定[CSS变量](http://dev.w3.org/csswg/css-variables/)规范的草案）

### 嵌套
编写CSS的时候，选择器链很常见。

```css
/* 选择器链 */
.nav > li {
    float: left;
}

.nav > li > a {
    display: block;
}
```
嵌套可以使得这些样式能够在预编译CSS文件中有更加清晰的分组
```scss
.nav {
    > li { 
        float: left;
        > a {
            display: block;
        }
    }
}
```
每一组样式都嵌套在上面的样式中。下面的代码看起来像是如何产生的？

```css
/* Sass生成的CSS */
.nav > li {
  float: left; }
  .nav > li > a {
    display: block; }
```
嵌套有助于理清样式和元素的关系，但是和自己缩进的样式并没有什么区别。另外，还可以减少你的输入，不用每次都输入`.nav`。

### 混入（Mixins）

混入（Mixins）十分强大。混入是一组CSS样式，可以在你的CSS中重用，并且可以传入参数，定制它的输出。混入最常见的一个功能是处理浏览器厂商的前缀。（）
```scss
// border-radius的混入示例
@mixin border-radius($size) {
  -webkit-border-radius: $size;
     -moz-border-radius: $size;
          border-radius: $size;
}
```
只要你定义了混入，那你就可以在CSS的任何地方通过`include`指令来调用它。

```scss
// border-radius的混入示例
.callout {
    @include border-radius(5px);
}
```
预处理器会将其编译成以下代码
```css
/* 为border-radius混入生成CSS */
.callout {
  -webkit-border-radius: 5px;
     -moz-border-radius: 5px;
          border-radius: 5px;
}
```
### 函数

混入看起来已经像一个函数了。但是，Sass中的函数却能做更加强大的计算。例如，`lighten`函数允许传入一个颜色值和百分比，返回亮度调整后的颜色值。
```scss
// 使用函数调整颜色值
$btnColor: #036;
.btn { 
    background-color: $btnColor; 
}
.btn:hover { 
    background-color: lighten($btnColor, 20%); 
}
```
Sass自带很多这样方便的函数，Compass甚至提供了更多。（如果你打算使用Sass，我强烈推荐你使用Compass）

### 扩展
扩展能够让一个模块拥有另一个模块的属性。在Sass中，我们可以使用`extend`指令。

```scss
// scss扩展
.btn { 
    display: block;
    padding: 5px 10px;
    background-color: #003366; 
}
.btn-default { 
    @extend .btn;
    background-color: #0066cc; 
}
```
Sass扩展会将`btn`中的样式应用与`btn-default`。Sass相当智能，它不会只是将规则简单地复制到`btn-default`，而是创建一个为第一组规则创建一个联合选择器。

```css
/* 将Sass扩展语法编译为CSS */
.btn, .btn-default {
  display: block;
  padding: 5px 10px;
  background-color: #003366; }

.btn-default {
  background-color: #0066cc; }
```
扩展仅限于简单的选择器，例如，你不能扩展`#main .btn`。在本章后面，我们将会对扩展做进一步的讨论，分析它们是如何在SMACSS中进行应用的。

### 多说一句
这些只是预处理器的冰山一角，在它们的官网上有更多的特性和例子的介绍。起初可能会让你有些望而生畏，但是不要一开始就想着使用它们的所有特性。

## 
你可能听过这样一句话：“拥有权利的同时也被赋予了重大的责任”。这些预处理器提供了很多强大的功能，使得你的CSS预编译文件精简而优美。但是，一旦这些文件进行编译后，你的CSS文件可能变得臃肿并且难以调试。换句话说，你回到了原点😭。你的代码可能是手工写的，也可能是使用像Dreamweaver这样的所见即所得工具，甚至是通过命令行使用预编预器，但是不管你使用哪一种，代码都有可能会变得臃肿。当然，也可能写出出色的代码😜

让我们来看下我们会在哪里遇到麻烦

### 深嵌套
使用嵌套，你很容易会越嵌套越深，试想一下，如果你有如下代码：
```scss
// Sass深嵌套
#sidebar {
  width: 300px;
  .box {
    border-radius: 10px;
    background-color: #EEE;
    h2 {
      font-size: 14px;
      font-weight: bold;
    }
    ul {
      margin:0;
      padding:0;
      a {
        display:block;
      }
    }
  }
}
```
这样的代码并不常见。我在工作中发现一个Sass文件里是这样写的。下面是它生成的代码：

```css
/* 使用深层嵌套的Sass编译生成的CSS */
#sidebar {
  width: 300px; }
  #sidebar .box {
    border-radius: 10px;
    background-color: #EEE; }
    #sidebar .box h2 {
      font-size: 14px;
      font-weight: bold; }
    #sidebar .box ul {
      margin: 0;
      padding: 0; }
      #sidebar .box ul a {
        display: block; }
```

### SMACSS中的嵌套

SMACSS的适用性深度性质，决定了它需要最小化的深度嵌套。布局和模块的分离也避免了这些问题。如果使用嵌套，之前的例子可能会像下面一样：

```css
/* SMACSS中的深度嵌套 */
#sidebar {
  width: 300px;
}

.box {
  border-radius: 10px;
  background-color: #EEE;
}

.box-header {
  font-size: 14px;
  font-weight: bold;
}

.box-body {
  margin: 0;
  padding: 0;
  a {
    display: block;
  }
}
```

几乎没有嵌套！！！这是因为我们没有必要用长长的选择器去获取样式。只有在需要定位模块中某个部分的元素时，我们才需要去考虑嵌套的问题。

而且对于浏览器来说，长长的选择器链远比样式规则确认更难处理。

### 不必要的扩展
让我们回到`btn-default`那个例子，再次看下之前的代码示例。

```scss
// 按钮Sass扩展
.btn { 
    display: block;
    padding: 5px 10px;
    background-color: #003366; 
}
.btn-default { 
    @extend .btn;
    background-color: #0066cc; 
}
```
这个方法让我们在HTML中，不再需要为元素指定`btn`和`btn-default`两个类名，只需要指定一个`btn-default`。我们将多余的声明从HTML中搬到了CSS中。
```css
/* 类名在链接上的应用 */
<a class="btn-default">My button</a>
```
扩展出一个子模块是避免在HTML中定义多个类名的方法之一。这时，命名规范会十分重要。如果一个模块名为`btn`，而子模块名为`small`，将`small`应用于元素，这时问题会变得更加复杂，我们根本不知道`small`是什么含义。所以，我们需要使用`btn-small`，我们可以将其作为子模块名，而且也知道这个模块的用处。

而查看Sass源码，我们同样可以知道`btn-default`是一个子模块，因为我们使用了`@extend`。而查看生成之后的源码，我们也可以知道`btn-default`是一个子模块，因为很明显，它是和`btn`类一组的。

扩展模块不适用于跨模块扩展。
```scss
// 跨模块Sass扩展
.box { 
    border-radius: 5px;
    box-shadow: 0 0 3px 0 #000000;
    background-color: #003366; 
    
}
.btn { 
    @extend .box;
    background-color: #0066cc; 
}
```
跨模块扩展将两个关注点绑定在一起。模块的样式将会有多个来源，不再是一对一。而像这样对CSS进行分组的后果就是你将会失去实时加载和按需编译的能力。你的*button*和*box*模块需要被同时加载。

甚至于在同一个模块中扩展也会导致一个做实时加载的项目更加复杂。所以，在雅虎，我们会在页面加载时就加载默认样式，但是只有在应用请求时，才加载次级样式。这会让初始页面加载更加快速。

### SMACSS扩展